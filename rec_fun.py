#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Wed Jun 30 09:14:03 2021@author: Nurlat Bekdullayev@email: nurlat.bekdullayev@kaust.edu.sa"""# =============================================================================# This script contains functions that find estimate of a point in 3D space# Input is 2 projections of the point on left and right halves of the sensor# 37 parameters describe translations/rotations between Target Coordinage System# and Sensor Coordinate System# =============================================================================import numpy as npfrom scipy.spatial.transform import Rotation     #main function that provides estimate of a point in 3Ddef rec_fun(uL,vL,uR,vR,            t1=None,t2=None,t3=None,            Theta1=None,Theta2=None,Theta3=None,            XLeftOu=None,YLeftOu=None,ZLeftOu=None,            nxLeftOu=None,nyLeftOu=None,nzLeftOu=None,            XLens=None,YLens=None,ZLens=None,            XSensor=None,YSensor=None,ZSensor=None,            nxSensor=None,nySensor=None,nzSensor=None,            X_LR=None,Y_LR=None,Z_LR=None,            Theta1_LR=None,Theta2_LR=None,Theta3_LR=None,            XRightOu=None,YRightOu=None,ZRightOu=None,            nxRightOu=None,nyRightOu=None,nzRightOu=None,            mx=None,my=None,u0=None,v0=None):        param = np.array([t1,t2,t3,Theta1,Theta2,Theta3,XLeftOu, YLeftOu, ZLeftOu, nxLeftOu,\                    nyLeftOu, nzLeftOu, XLens, YLens, ZLens,\                    XSensor, YSensor, ZSensor,nxSensor, nySensor, nzSensor,\                    X_LR,Y_LR,Z_LR,Theta1_LR,Theta2_LR,Theta3_LR,\                    XRightOu, YRightOu, ZRightOu, nxRightOu, nyRightOu, nzRightOu,\                    mx,my,u0,v0])         PXLeftOu, PYLeftOu, PZLeftOu,\        nxLeftOuReflection, nyLeftOuReflection, nzLeftOuReflection = \            point_left_outer(uL, vL, param)                PXRightOu,PYRightOu,PZRightOu,\        nxRightOuReflection,nyRightOuReflection,nzRightOuReflection = \            point_right_outer(uR, vR, param)                LeftLine = np.array([PXLeftOu, PYLeftOu, PZLeftOu,\        nxLeftOuReflection, nyLeftOuReflection, nzLeftOuReflection])            RightLine = np.array([PXRightOu,PYRightOu,PZRightOu,\        nxRightOuReflection,nyRightOuReflection,nzRightOuReflection])            PX, PY, PZ = middle_point_rec(LeftLine, RightLine)        Rot = Rotation.from_euler('ZYX', np.array([-Theta1, -Theta2, -Theta3]))    Rot = Rot.as_matrix()    T = np.array([t1, t2, t3])    P_LeftIn = np.array([PX, PY, PZ])    P_local = np.linalg.inv(Rot) @ (P_LeftIn - T)        return P_local#def rec_fun_wrapped(point_set, const_dict, var_dict, numpy_row):    for index, key in enumerate(var_dict.keys()):        var_dict[key] = numpy_row[index]    return rec_fun(*point_set, **const_dict, **var_dict)# function to get a skew matrix of a vec 3x1def skew_vector(vec):    skew_vec = \        np.array([[0, -vec[2], vec[1]], [vec[2], 0, -vec[0]], [-vec[1], vec[0], 0]])    return skew_vec# function to find rotation matrix R from v1 to v2def rotate_vector(v1, v2):    w = np.cross(v1, v2)    w = w/np.linalg.norm(w)    w_hat = skew_vector(w)    cos_tht = np.transpose(v1)@v2/np.linalg.norm(v1)/np.linalg.norm(v2)    tht = np.arccos(cos_tht)        R = np.identity(np.size(v1)) + w_hat*np.sin(tht) + w_hat@ w_hat*(1 - np.cos(tht))    return R# functions to obtain function describing the last ray from the left# and right outer mirrordef point_left_outer(uL, vL, param):    XLeftOu = param[6]    YLeftOu = param[7]    ZLeftOu = param[8]    nxLeftOu = param[9]    nyLeftOu = param[10]    nzLeftOu = param[11]    XLens = param[12]    YLens = param[13]    ZLens = param[14]          XSensor = param[15]    YSensor = param[16]    ZSensor = param[17]    nxSensor = param[18]    nySensor = param[19]    nzSensor = param[20]    mx = param[33]    my = param[34]    u0 = param[35]    v0 = param[36]        # 3D coordinate of a left image point in the sensor plane    PSensorLeft_x = -(uL-u0)*mx    PSensorLeft_y = -(vL-v0)*my    PSensorLeft = np.array([PSensorLeft_x, PSensorLeft_y, 0])        # 3D coordinate of a left image point in left inner mirror    OLeftIn = np.array([0,0,0])    NormalVectorLeftIn = np.array([0,0,1])    OSensorLeft = np.array([XSensor, YSensor, ZSensor])    NormalVectorSensorLeft = np.array([nxSensor, nySensor, nzSensor])    PSensorLeftIn = rotate_vector(np.transpose(NormalVectorLeftIn),\                                  np.transpose(NormalVectorSensorLeft))\        @ np.transpose(PSensorLeft) + np.transpose(OSensorLeft - OLeftIn)    xRightSensor = PSensorLeftIn[0]    yRightSensor = PSensorLeftIn[1]    zRightSenor = PSensorLeftIn[2]        # finding equation for the optical path leaving left outer mirror    PXLeftOu=(nxLeftOu*XLeftOu*(XLens+(-1)*xRightSensor)+nyLeftOu*xRightSensor*( \    (-1)*YLeftOu+YLens)+nyLeftOu*XLens*(YLeftOu+(-1)*yRightSensor)+(-1) \    *nzLeftOu*xRightSensor*(ZLeftOu+ZLens)+nzLeftOu*XLens*(ZLeftOu+ \     zRightSenor))*(nxLeftOu*(XLens+(-1)*xRightSensor)+nyLeftOu*(YLens+( \    -1)*yRightSensor)+nzLeftOu*((-1)*ZLens+ zRightSenor))**(-1)                                                                           PYLeftOu=(nyLeftOu*YLeftOu*(YLens+(-1)*yRightSensor)+nxLeftOu*((-1)* \    xRightSensor*YLens+XLeftOu*(YLens+(-1)*yRightSensor)+XLens* \    yRightSensor)+(-1)*nzLeftOu*yRightSensor*(ZLeftOu+ZLens)+nzLeftOu* \    YLens*(ZLeftOu+ zRightSenor))*(nxLeftOu*(XLens+(-1)*xRightSensor)+ \    nyLeftOu*(YLens+(-1)*yRightSensor)+nzLeftOu*((-1)*ZLens+ zRightSenor) \    )**(-1)          PZLeftOu=(nxLeftOu*(XLens+(-1)*xRightSensor)+nyLeftOu*(YLens+(-1)* \    yRightSensor)+nzLeftOu*((-1)*ZLens+ zRightSenor))**(-1)*(nzLeftOu* \    ZLeftOu*((-1)*ZLens+ zRightSenor)+nyLeftOu*((-1)*YLeftOu*ZLens+ \    yRightSensor*ZLens+YLeftOu* zRightSenor+(-1)*YLens* zRightSenor)+ \    nxLeftOu*(xRightSensor*ZLens+(-1)*XLens* zRightSenor+XLeftOu*((-1)* \    ZLens+ zRightSenor)))        nxLeftOuReflection=(XLens+(-2)*nxLeftOu**2*XLens+((-1)+2*nxLeftOu**2)*xRightSensor+2* \    nxLeftOu*((-1)*nyLeftOu*YLens+nyLeftOu*yRightSensor+nzLeftOu*ZLens+ \    (-1)*nzLeftOu* zRightSenor))*(abs(XLens+(-1)*xRightSensor)**2+abs( \    YLens+(-1)*yRightSensor)**2+abs(ZLens+(-1)* zRightSenor)**2)**(-1/2)        nyLeftOuReflection=(2*nxLeftOu*nyLeftOu*((-1)*XLens+xRightSensor)+YLens+(-2)* \    nyLeftOu**2*YLens+(-1)*yRightSensor+2*nyLeftOu**2*yRightSensor+2* \    nyLeftOu*nzLeftOu*ZLens+(-2)*nyLeftOu*nzLeftOu* zRightSenor)*(abs( \    XLens+(-1)*xRightSensor)**2+abs(YLens+(-1)*yRightSensor)**2+abs(ZLens+ \    (-1)* zRightSenor)**2)**(-1/2)        nzLeftOuReflection=(2*nxLeftOu*nzLeftOu*((-1)*XLens+xRightSensor)+2*nyLeftOu* \    nzLeftOu*((-1)*YLens+yRightSensor)+((-1)+2*nzLeftOu**2)*(ZLens+(-1) \    * zRightSenor))*(abs(XLens+(-1)*xRightSensor)**2+abs(YLens+(-1)* \    yRightSensor)**2+abs(ZLens+(-1)* zRightSenor)**2)**(-1/2)                                                             return PXLeftOu, PYLeftOu, PZLeftOu,\        nxLeftOuReflection, nyLeftOuReflection, nzLeftOuReflectiondef point_right_outer(uR,vR,param):    XLens = param[12]    YLens = param[13]    ZLens = param[14]          XSensor = param[15]    YSensor = param[16]    ZSensor = param[17]    nxSensor = param[18]    nySensor = param[19]    nzSensor = param[20]    X_LR = param[21]    Y_LR = param[22]    Z_LR = param[23]    Theta1_LR = param[24]    Theta2_LR = param[25]    Theta3_LR = param[26]    XRightOu = param[27]    YRightOu = param[28]    ZRightOu = param[29]    nxRightOu = param[30]    nyRightOu = param[31]    nzRightOu = param[32]    mx = param[33]    my = param[34]    u0 = param[35]    v0 = param[36]        PSensorRight_x = -(uR-u0)*mx    PSensorRight_y = -(vR-v0)*my    PSensorRight = np.array([PSensorRight_x, PSensorRight_y, 0])            OLeftIn = np.array([0,0,0])    NormalVectorLeftIn = np.array([0,0,1])    OSensorLeft = np.array([XSensor, YSensor, ZSensor])    NormalVectorSensorLeft = np.array([nxSensor, nySensor, nzSensor])    PSensorLeftIn = rotate_vector(np.transpose(NormalVectorLeftIn),\                                  np.transpose(NormalVectorSensorLeft))\        @ np.transpose(PSensorRight) + np.transpose(OSensorLeft - OLeftIn)    xLeftSensor = PSensorLeftIn[0]    yLeftSensor = PSensorLeftIn[1]    zLeftSenor = PSensorLeftIn[2]        #displacement between right and left inner mirrors    T_LR = np.array([X_LR, Y_LR, Z_LR])    ORightIn = OLeftIn + T_LR    XRightIn = ORightIn[0]    YRightIn = ORightIn[1]    ZRightIn = ORightIn[2]        Rot = Rotation.from_euler('ZYX', np.array([Theta1_LR, Theta2_LR, Theta3_LR ]))    NormalVectorRightIn = Rot.as_matrix() @ np.transpose(NormalVectorLeftIn)    nxRightIn = NormalVectorRightIn[0]    nyRightIn = NormalVectorRightIn[1]    nzRightIn = NormalVectorRightIn[2]        ORightOu = np.array([XRightOu,YRightOu,ZRightOu])    ORightOu_LeftIn = Rot.as_matrix() @ \        np.transpose(ORightOu)+ np.transpose(T_LR)    XRightOu = ORightOu_LeftIn[0]    YRightOu = ORightOu_LeftIn[1]    ZRightOu = ORightOu_LeftIn[2]        NormalVectorRightOu = np.array([nxRightOu,nyRightOu,nzRightOu])    NormalVectorRightOu_LeftIn = Rot.as_matrix() @ np.transpose(NormalVectorRightOu)    nxRightOu = NormalVectorRightOu_LeftIn[0]    nyRightOu = NormalVectorRightOu_LeftIn[1]    nzRightOu = NormalVectorRightOu_LeftIn[2]        PXRightOu = (2*nxRightIn*(nyRightIn*nyRightOu + nzRightIn*nzRightOu)*( \    xLeftSensor + (-1)*XLens) + (-1)*nyRightOu*yLeftSensor + 2*nyRightIn**2* \    nyRightOu*yLeftSensor + 2*nyRightIn*nzRightIn*nzRightOu*yLeftSensor +  \    nyRightOu*YLens + (-2)*nyRightIn**2*nyRightOu*YLens + (-2)*nyRightIn* \    nzRightIn*nzRightOu*YLens + 2*nyRightIn*nyRightOu*nzRightIn* \    zLeftSenor + (-1)*nzRightOu*zLeftSenor + 2*nzRightIn**2*nzRightOu* \    zLeftSenor + (-2)*nyRightIn*nyRightOu*nzRightIn*ZLens + nzRightOu* \    ZLens + (-2)*nzRightIn**2*nzRightOu*ZLens + nxRightOu*(((-1) + 2* \    nxRightIn**2)*xLeftSensor + XLens + (-2)*nxRightIn**2*XLens + 2* \    nxRightIn*(nyRightIn*yLeftSensor + (-1)*nyRightIn*YLens + nzRightIn* \    zLeftSenor + (-1)*nzRightIn*ZLens)))**(-1)*(nxRightOu*((-1)* \    xLeftSensor + XLens)*XRightOu + (-1)*nyRightOu*XLens*yLeftSensor + 2* \    nyRightIn**2*nyRightOu*XLens*yLeftSensor + 2*nyRightIn*nzRightIn* \    nzRightOu*XLens*yLeftSensor + nyRightOu*xLeftSensor*YLens + (-2)* \    nyRightIn**2*nyRightOu*xLeftSensor*YLens + (-2)*nyRightIn*nzRightIn* \    nzRightOu*xLeftSensor*YLens + 2*nyRightIn**2*nyRightOu*xLeftSensor* \    YRightIn + 2*nyRightIn*nzRightIn*nzRightOu*xLeftSensor*YRightIn + (-2) \    *nyRightIn**2*nyRightOu*XLens*YRightIn + (-2)*nyRightIn*nzRightIn* \    nzRightOu*XLens*YRightIn + (-1)*nyRightOu*xLeftSensor*YRightOu +  \    nyRightOu*XLens*YRightOu + 2*nyRightIn*nyRightOu*nzRightIn*XLens* \    zLeftSenor + (-1)*nzRightOu*XLens*zLeftSenor + 2*nzRightIn**2* \    nzRightOu*XLens*zLeftSenor + (-2)*nyRightIn*nyRightOu*nzRightIn* \    xLeftSensor*ZLens + nzRightOu*xLeftSensor*ZLens + (-2)*nzRightIn**2* \    nzRightOu*xLeftSensor*ZLens + 2*nyRightIn*nyRightOu*nzRightIn* \    xLeftSensor*ZRightIn + 2*nzRightIn**2*nzRightOu*xLeftSensor*ZRightIn +  \    (-2)*nyRightIn*nyRightOu*nzRightIn*XLens*ZRightIn + (-2)* \    nzRightIn**2*nzRightOu*XLens*ZRightIn + (-1)*nzRightOu*xLeftSensor* \    ZRightOu + nzRightOu*XLens*ZRightOu + 2*nxRightIn**2*(nxRightOu*( \    xLeftSensor + (-1)*XLens)*XRightOu + nyRightOu*(XLens*yLeftSensor + (-1)* \    XRightIn*yLeftSensor + (-1)*xLeftSensor*YLens + XRightIn*YLens +  \    xLeftSensor*YRightOu + (-1)*XLens*YRightOu) + nzRightOu*(XLens* \    zLeftSenor + (-1)*XRightIn*zLeftSenor + (-1)*xLeftSensor*ZLens +  \    XRightIn*ZLens + xLeftSensor*ZRightOu + (-1)*XLens*ZRightOu)) + 2* \    nxRightIn*(nzRightIn*(nxRightOu*XRightOu*(zLeftSenor + (-1)*ZLens) +  \    nyRightOu*(YRightOu*(zLeftSenor + (-1)*ZLens) + yLeftSensor*(ZLens + (-1) \    *ZRightIn) + YLens*((-1)*zLeftSenor + ZRightIn)) + nzRightOu*( \    xLeftSensor*XRightIn + (-1)*XLens*XRightIn + (-1)*(zLeftSenor + (-1)* \    ZLens)*(ZRightIn + (-1)*ZRightOu))) + nyRightIn*(nxRightOu*XRightOu*( \    yLeftSensor + (-1)*YLens) + nyRightOu*(xLeftSensor*XRightIn + (-1)*XLens* \    XRightIn + (-1)*(yLeftSensor + (-1)*YLens)*(YRightIn + (-1)*YRightOu)) +  \    nzRightOu*(YRightIn*((-1)*zLeftSenor + ZLens) + YLens*(zLeftSenor + (-1)* \    ZRightOu) + yLeftSensor*((-1)*ZLens + ZRightOu)))))        PYRightOu = (2*nxRightIn*(nyRightIn*nyRightOu + nzRightIn*nzRightOu)*( \    xLeftSensor + (-1)*XLens) + (-1)*nyRightOu*yLeftSensor + 2*nyRightIn**2* \    nyRightOu*yLeftSensor + 2*nyRightIn*nzRightIn*nzRightOu*yLeftSensor +  \    nyRightOu*YLens + (-2)*nyRightIn**2*nyRightOu*YLens + (-2)*nyRightIn* \    nzRightIn*nzRightOu*YLens + 2*nyRightIn*nyRightOu*nzRightIn* \    zLeftSenor + (-1)*nzRightOu*zLeftSenor + 2*nzRightIn**2*nzRightOu* \    zLeftSenor + (-2)*nyRightIn*nyRightOu*nzRightIn*ZLens + nzRightOu* \    ZLens + (-2)*nzRightIn**2*nzRightOu*ZLens + nxRightOu*(((-1) + 2* \    nxRightIn**2)*xLeftSensor + XLens + (-2)*nxRightIn**2*XLens + 2* \    nxRightIn*(nyRightIn*yLeftSensor + (-1)*nyRightIn*YLens + nzRightIn* \    zLeftSenor + (-1)*nzRightIn*ZLens)))**(-1)*((-2)*nxRightIn**2* \    nxRightOu*(XLens*yLeftSensor + (-1)*xLeftSensor*YLens + XRightIn*((-1) \    *yLeftSensor + YLens)) + 2*nyRightIn*nzRightIn*nzRightOu*yLeftSensor* \    YRightIn + (-2)*nyRightIn*nzRightIn*nzRightOu*YLens*YRightIn + (-1)* \    nyRightOu*yLeftSensor*YRightOu + 2*nyRightIn**2*nyRightOu* \    yLeftSensor*YRightOu + nyRightOu*YLens*YRightOu + (-2)*nyRightIn**2* \    nyRightOu*YLens*YRightOu + (-1)*nzRightOu*YLens*zLeftSenor + 2* \    nyRightIn**2*nzRightOu*YLens*zLeftSenor + 2*nzRightIn**2*nzRightOu* \    YLens*zLeftSenor + (-2)*nyRightIn**2*nzRightOu*YRightIn*zLeftSenor +  \    2*nyRightIn*nyRightOu*nzRightIn*YRightOu*zLeftSenor + nzRightOu* \    yLeftSensor*ZLens + (-2)*nyRightIn**2*nzRightOu*yLeftSensor*ZLens + ( \    -2)*nzRightIn**2*nzRightOu*yLeftSensor*ZLens + 2*nyRightIn**2* \    nzRightOu*YRightIn*ZLens + (-2)*nyRightIn*nyRightOu*nzRightIn* \    YRightOu*ZLens + 2*nzRightIn**2*nzRightOu*yLeftSensor*ZRightIn + (-2)* \    nzRightIn**2*nzRightOu*YLens*ZRightIn + (-2)*nyRightIn*nzRightIn* \    nzRightOu*zLeftSenor*ZRightIn + 2*nyRightIn*nzRightIn*nzRightOu* \    ZLens*ZRightIn + nxRightOu*(XRightOu*(((-1) + 2*nyRightIn**2)* \    yLeftSensor + YLens + (-2)*nyRightIn**2*YLens + 2*nyRightIn*nzRightIn*( \    zLeftSenor + (-1)*ZLens)) + XLens*(yLeftSensor + (-2)*nyRightIn**2* \    yLeftSensor + 2*nyRightIn*(nyRightIn*YRightIn + nzRightIn*((-1)* \    zLeftSenor + ZRightIn))) + xLeftSensor*(((-1) + 2*nyRightIn**2)*YLens + (-2) \    *nyRightIn*(nyRightIn*YRightIn + nzRightIn*((-1)*ZLens + ZRightIn)))) + ( \    -1)*nzRightOu*yLeftSensor*ZRightOu + 2*nyRightIn**2*nzRightOu* \    yLeftSensor*ZRightOu + nzRightOu*YLens*ZRightOu + (-2)*nyRightIn**2* \    nzRightOu*YLens*ZRightOu + 2*nyRightIn*nzRightIn*nzRightOu* \    zLeftSenor*ZRightOu + (-2)*nyRightIn*nzRightIn*nzRightOu*ZLens* \    ZRightOu + (-2)*nxRightIn*(nzRightIn*nzRightOu*(XLens*yLeftSensor + ( \    -1)*XRightIn*yLeftSensor + (-1)*xLeftSensor*YLens + XRightIn*YLens) +  \    nyRightIn*nyRightOu*((-1)*xLeftSensor + XLens)*YRightOu + nxRightOu*( \    nyRightIn*(xLeftSensor*XRightIn + (-1)*XLens*XRightIn + (-1)* \    xLeftSensor*XRightOu + XLens*XRightOu + (-1)*yLeftSensor*YRightIn +  \    YLens*YRightIn) + nzRightIn*((-1)*YLens*zLeftSenor + yLeftSensor*ZLens +  \    (-1)*yLeftSensor*ZRightIn + YLens*ZRightIn)) + nyRightIn*nzRightOu*( \    XRightIn*zLeftSenor + xLeftSensor*ZLens + (-1)*XRightIn*ZLens + (-1)* \    xLeftSensor*ZRightOu + XLens*((-1)*zLeftSenor + ZRightOu))))        PZRightOu = (2*nxRightIn*(nyRightIn*nyRightOu + nzRightIn*nzRightOu)*( \    xLeftSensor + (-1)*XLens) + (-1)*nyRightOu*yLeftSensor + 2*nyRightIn**2* \    nyRightOu*yLeftSensor + 2*nyRightIn*nzRightIn*nzRightOu*yLeftSensor +  \    nyRightOu*YLens + (-2)*nyRightIn**2*nyRightOu*YLens + (-2)*nyRightIn* \    nzRightIn*nzRightOu*YLens + 2*nyRightIn*nyRightOu*nzRightIn* \    zLeftSenor + (-1)*nzRightOu*zLeftSenor + 2*nzRightIn**2*nzRightOu* \    zLeftSenor + (-2)*nyRightIn*nyRightOu*nzRightIn*ZLens + nzRightOu* \    ZLens + (-2)*nzRightIn**2*nzRightOu*ZLens + nxRightOu*(((-1) + 2* \    nxRightIn**2)*xLeftSensor + XLens + (-2)*nxRightIn**2*XLens + 2* \    nxRightIn*(nyRightIn*yLeftSensor + (-1)*nyRightIn*YLens + nzRightIn* \    zLeftSenor + (-1)*nzRightIn*ZLens)))**(-1)*((-2)*nyRightIn* \    nyRightOu*nzRightIn*yLeftSensor*YRightIn + 2*nyRightIn*nyRightOu* \    nzRightIn*YLens*YRightIn + 2*nyRightIn*nyRightOu*nzRightIn* \    yLeftSensor*YRightOu + (-2)*nyRightIn*nyRightOu*nzRightIn*YLens* \    YRightOu + nyRightOu*YLens*zLeftSenor + (-2)*nyRightIn**2*nyRightOu* \    YLens*zLeftSenor + (-2)*nyRightOu*nzRightIn**2*YLens*zLeftSenor + 2* \    nyRightIn**2*nyRightOu*YRightIn*zLeftSenor + (-1)*nyRightOu* \    YRightOu*zLeftSenor + 2*nyRightOu*nzRightIn**2*YRightOu*zLeftSenor + ( \    -1)*nyRightOu*yLeftSensor*ZLens + 2*nyRightIn**2*nyRightOu* \    yLeftSensor*ZLens + 2*nyRightOu*nzRightIn**2*yLeftSensor*ZLens + (-2)* \    nyRightIn**2*nyRightOu*YRightIn*ZLens + nyRightOu*YRightOu*ZLens + (-2) \    *nyRightOu*nzRightIn**2*YRightOu*ZLens + (-2)*nxRightIn**2* \    nxRightOu*(XLens*zLeftSenor + (-1)*xLeftSensor*ZLens + XRightIn*((-1)* \    zLeftSenor + ZLens)) + (-2)*nyRightOu*nzRightIn**2*yLeftSensor*ZRightIn +  \    2*nyRightOu*nzRightIn**2*YLens*ZRightIn + 2*nyRightIn*nyRightOu* \    nzRightIn*zLeftSenor*ZRightIn + (-2)*nyRightIn*nyRightOu*nzRightIn* \    ZLens*ZRightIn + nxRightOu*(2*nyRightIn*nzRightIn*(XRightOu* \    yLeftSensor + xLeftSensor*YLens + (-1)*XRightOu*YLens + (-1)*xLeftSensor* \    YRightIn + XLens*((-1)*yLeftSensor + YRightIn)) + (-1)*XRightOu* \    zLeftSenor + 2*nzRightIn**2*XRightOu*zLeftSenor + (-1)*xLeftSensor* \    ZLens + 2*nzRightIn**2*xLeftSensor*ZLens + XRightOu*ZLens + (-2)* \    nzRightIn**2*XRightOu*ZLens + (-2)*nzRightIn**2*xLeftSensor*ZRightIn +  \    XLens*(zLeftSenor + (-2)*nzRightIn**2*zLeftSenor + 2*nzRightIn**2* \    ZRightIn)) + 2*nyRightIn*nzRightIn*nzRightOu*yLeftSensor*ZRightOu + ( \    -2)*nyRightIn*nzRightIn*nzRightOu*YLens*ZRightOu + (-1)*nzRightOu* \    zLeftSenor*ZRightOu + 2*nzRightIn**2*nzRightOu*zLeftSenor*ZRightOu +  \    nzRightOu*ZLens*ZRightOu + (-2)*nzRightIn**2*nzRightOu*ZLens* \    ZRightOu + (-2)*nxRightIn*(nyRightOu*nzRightIn*(XRightIn*yLeftSensor +  \    xLeftSensor*YLens + (-1)*XRightIn*YLens + (-1)*xLeftSensor*YRightOu +  \    XLens*((-1)*yLeftSensor + YRightOu)) + nyRightIn*nyRightOu*(XLens* \    zLeftSenor + (-1)*XRightIn*zLeftSenor + (-1)*xLeftSensor*ZLens +  \    XRightIn*ZLens) + nxRightOu*(nyRightIn*(YLens*zLeftSenor + (-1)* \    YRightIn*zLeftSenor + (-1)*yLeftSensor*ZLens + YRightIn*ZLens) +  \    nzRightIn*(xLeftSensor*XRightIn + (-1)*XLens*XRightIn + (-1)* \    xLeftSensor*XRightOu + XLens*XRightOu + (-1)*zLeftSenor*ZRightIn + ZLens* \    ZRightIn)) + nzRightIn*nzRightOu*((-1)*xLeftSensor + XLens)*ZRightOu)) \        nxRightOuReflection = ((-1)*(1 + (-2)*nxRightOu**2 + nxRightIn**2*((-2) + 4*nxRightOu**2) + 4* \    nxRightIn*nxRightOu*(nyRightIn*nyRightOu + nzRightIn*nzRightOu))* \    xLeftSensor + (1 + (-2)*nxRightOu**2 + nxRightIn**2*((-2) + 4*nxRightOu**2) +  \    4*nxRightIn*nxRightOu*(nyRightIn*nyRightOu + nzRightIn*nzRightOu))* \    XLens + (-2)*(nxRightOu*(nyRightOu*(((-1) + 2*nyRightIn**2)* \    yLeftSensor + YLens + (-2)*nyRightIn**2*YLens + 2*nyRightIn*nzRightIn*( \    zLeftSenor + (-1)*ZLens)) + nzRightOu*(2*nyRightIn*nzRightIn*( \    yLeftSensor + (-1)*YLens) + ((-1) + 2*nzRightIn**2)*(zLeftSenor + (-1)* \    ZLens))) + nxRightIn*((-1) + 2*nxRightOu**2)*(nyRightIn*(yLeftSensor + ( \    -1)*YLens) + nzRightIn*(zLeftSenor + (-1)*ZLens))))*(abs(xLeftSensor + ( \    -1)*XLens)**2 + abs(yLeftSensor + (-1)*YLens)**2 + abs(zLeftSenor + (-1)* \    ZLens)**2)**(-1/2)        nyRightOuReflection = (2*nxRightOu*nyRightOu*(xLeftSensor + (-1)*XLens) + 4*nxRightIn**2* \    nxRightOu*nyRightOu*((-1)*xLeftSensor + XLens) + (-1)*yLeftSensor + 2* \    nyRightIn**2*yLeftSensor + 2*nyRightOu**2*yLeftSensor + (-4)* \    nyRightIn**2*nyRightOu**2*yLeftSensor + (-4)*nyRightIn*nyRightOu* \    nzRightIn*nzRightOu*yLeftSensor + (-2)*nxRightIn*nyRightIn*(((-1) + 2* \    nyRightOu**2)*xLeftSensor + XLens + (-2)*nyRightOu**2*XLens + 2* \    nxRightOu*nyRightOu*(yLeftSensor + (-1)*YLens)) + YLens + (-2)* \    nyRightIn**2*YLens + (-2)*nyRightOu**2*YLens + 4*nyRightIn**2* \    nyRightOu**2*YLens + 4*nyRightIn*nyRightOu*nzRightIn*nzRightOu* \    YLens + 2*nyRightIn*nzRightIn*zLeftSenor + (-4)*nyRightIn* \    nyRightOu**2*nzRightIn*zLeftSenor + 2*nyRightOu*nzRightOu*zLeftSenor +  \    (-4)*nyRightOu*nzRightIn**2*nzRightOu*zLeftSenor + (-2)*nyRightIn* \    nzRightIn*ZLens + 4*nyRightIn*nyRightOu**2*nzRightIn*ZLens + (-2)* \    nyRightOu*nzRightOu*ZLens + 4*nyRightOu*nzRightIn**2*nzRightOu* \    ZLens + 4*nxRightIn*nyRightOu*nzRightIn*(nzRightOu*((-1)* \    xLeftSensor + XLens) + nxRightOu*((-1)*zLeftSenor + ZLens)))*(abs( \    xLeftSensor + (-1)*XLens)**2 + abs(yLeftSensor + (-1)*YLens)**2 + abs( \    zLeftSenor + (-1)*ZLens)**2)**(-1/2)        nzRightOuReflection = (2*nxRightOu*nzRightOu*(xLeftSensor + (-1)*XLens) + 4*nxRightIn**2* \    nxRightOu*nzRightOu*((-1)*xLeftSensor + XLens) + 2*nyRightIn* \    nzRightIn*yLeftSensor + 2*nyRightOu*nzRightOu*yLeftSensor + (-4)* \    nyRightIn**2*nyRightOu*nzRightOu*yLeftSensor + (-4)*nyRightIn* \    nzRightIn*nzRightOu**2*yLeftSensor + (-2)*nyRightIn*nzRightIn*YLens + ( \    -2)*nyRightOu*nzRightOu*YLens + 4*nyRightIn**2*nyRightOu*nzRightOu* \    YLens + 4*nyRightIn*nzRightIn*nzRightOu**2*YLens + 4*nxRightIn* \    nyRightIn*nzRightOu*(nyRightOu*((-1)*xLeftSensor + XLens) + nxRightOu*( \    (-1)*yLeftSensor + YLens)) + (-1)*zLeftSenor + 2*nzRightIn**2*zLeftSenor + ( \    -4)*nyRightIn*nyRightOu*nzRightIn*nzRightOu*zLeftSenor + 2* \    nzRightOu**2*zLeftSenor + (-4)*nzRightIn**2*nzRightOu**2*zLeftSenor + ( \    -2)*nxRightIn*nzRightIn*(((-1) + 2*nzRightOu**2)*xLeftSensor + XLens + ( \    -2)*nzRightOu**2*XLens + 2*nxRightOu*nzRightOu*(zLeftSenor + (-1)* \    ZLens)) + ZLens + (-2)*nzRightIn**2*ZLens + 4*nyRightIn*nyRightOu* \    nzRightIn*nzRightOu*ZLens + (-2)*nzRightOu**2*ZLens + 4*nzRightIn**2* \    nzRightOu**2*ZLens)*(abs(xLeftSensor + (-1)*XLens)**2 + abs(yLeftSensor + ( \    -1)*YLens)**2 + abs(zLeftSenor + (-1)*ZLens)**2)**(-1/2)        return PXRightOu,PYRightOu,PZRightOu,\        nxRightOuReflection,nyRightOuReflection,nzRightOuReflection#function to find closest point to vectors leaving left and right outer mirrorsdef middle_point_rec(line1,line2):    x1 = line1[0]    y1 = line1[1]    z1 = line1[2]    nx1 = line1[3]    ny1 = line1[4]    nz1 = line1[5]        x2 = line2[0]    y2 = line2[1]    z2 = line2[2]    nx2 = line2[3]    ny2 = line2[4]    nz2 = line2[5]        p1 = np.array([x1, y1, z1])    p2 = np.array([x2, y2, z2])    u1 = np.array([nx1, ny1, nz1])    u2 = np.array([nx2, ny2, nz2])        p21 = p2 - p1    m = np.cross(u2, u1)    m2 = np.dot(m, m)    r = np.cross(p21, m/m2)    t1 = np.dot(r, u2)    t2 = np.dot(r, u1)    q1 = p1 + t1*u1    q2 = p2 + t2*u2        point = (q1 + q2)/2    return point