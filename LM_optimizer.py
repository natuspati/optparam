import numpy as npimport scipy.io as sioimport matplotlib.pyplot as pltimport csvfrom scipy.optimize import least_squaresimport osfrom rec_fun import rec_fundef nonlinear_opt(param,m,M):    num_of_points = M.shape[1]    M_reconstruct = np.empty_like(M)    for i in range(0,num_of_points):        M_reconstruct[:,i] = functions.rec_fun(m[0,i],m[1,i],m[2,i],m[3,i],*param)    return np.linalg.norm(M-M_reconstruct, axis=0)                # def main():rows = []nominal_values = []with open('lipings_calibrated_parameters.csv') as csv_file:    csvreader = csv.reader(csv_file)    for row in csvreader:        rows.append(row)for x in range(1,len(rows)):     nominal_values.append(float(rows[x][2]))nominal_values = np.array(nominal_values)#load 3D points on target and image projectionsM_csv = open("M.csv")M = np.loadtxt(M_csv, delimiter=",")mL_csv = open("mL.csv")mL = np.loadtxt(mL_csv, delimiter=",")mR_csv = open("mR.csv")mR = np.loadtxt(mR_csv, delimiter=",")m = np.vstack((mL,mR))M_est = np.empty(M.shape)for x in range(m.shape[1]):    M_est[:,x] = functions.rec_fun(m[0,x],m[1,x],m[2,x],m[3,x],*nominal_values)res_1 = least_squares(nonlinear_opt,nominal_values,method='lm',xtol = 2.32e-16, verbose=2,args=(m,M))print(nominal_values-res_1.x)# plottingplt.close('all')fig = plt.figure()ax = fig.add_subplot(projection='3d')ax.scatter3D(M[0,:],M[1,:],M[2,:],marker='x')ax.scatter3D(M_est[0,:],M_est[1,:],M_est[2,:],marker='o')ax.legend(['Idealized M','Estimated M'])# path = '/Volumes/Windows/Users/bekdulnm/Google Drive/Research/Images_8_7/ExtractedFeatures'# m_names = []# for entry in os.scandir(path):#     if entry.name.endswith('.mat') and entry.name.startswith('m'):#         m_names.append(entry.name)# ms = np.zeros((4,112,12))# for i in range(0,int(len(m_names)/2)):#     if i+1 < 10:#         mLName = 'mL0' + str(i+1) + '.mat'#         mRName = 'mR0' + str(i+1) + '.mat'#     else:#         mLName = 'mL' + str(i+1) + '.mat'#         mRName = 'mR' + str(i+1) + '.mat'#     mL = sio.loadmat(mLName)#     mR = sio.loadmat(mRName)#     ms[:,:,i] = np.vstack((mL.get("mL"), mR.get("mR")))# # structral parameters for determing initial values# PhiIn =  np.pi/4# PhiOu = 52 * np.pi/180# d = 15# f = 4# DInOu = 34# # 3R+3T between the calibration target and left inner mirror# # distance bw target and phone about 43 cm in font (x,z plane)# # distance bet target and phone about 20 cm in highet (y axis)# t1 = -303# t2 = 20# t3 = 303# Theta1 = 0# Theta2 =  np.pi/2# Theta3 = 0# # position and normal vector of the left outer mirror with respect to the left inner mirror# XLeftOu = -DInOu/2 * np.cos(PhiIn)# YLeftOu = 0# ZLeftOu = -DInOu/2 * np.sin(PhiIn)# nxLeftOu =  np.sin(PhiOu-PhiIn)# nyLeftOu = 0# nzLeftOu =  np.cos(PhiOu-PhiIn)# # position and normal vector of the lens with respect to the left inner mirror# XLens = d * np.sin(PhiIn)# YLens = 0# ZLens = -d * np.cos(PhiIn)# # position and normal vector of the sensor with respect to the left inner mirror# XSensor = (d+f) * np.sin(PhiIn)# YSensor = 0# ZSensor = -(d+f) * np.cos(PhiIn)# nxSensor = - np.sin(PhiIn)# nySensor = 0# nzSensor =  np.cos(PhiIn)# # 3R+3T between left and right inner mirror# X_LR = 0# Y_LR = 0# Z_LR = 0# Theta1_LR = 0# Theta2_LR = - np.pi/2# Theta3_LR = 0# # position and normal vector of the right outer mirror with respect to the right inner mirror# XRightOu = DInOu/2 * np.cos(PhiIn)# YRightOu = 0# ZRightOu = -DInOu/2 * np.sin(PhiIn)# nxRightOu = - np.sin(PhiOu-PhiIn)# nyRightOu = 0# nzRightOu =  np.cos(PhiOu-PhiIn)# # mx and my are the physical size of the a  np.pixel, u0 and v0 are the image coordinate of the principle point# mx = 2.8*1e-3# my = 2.8*1e-3# u0 = 475/2# v0 = 275/2# param = [t1, t2, t3,Theta1,Theta2,Theta3\#        , XLeftOu, YLeftOu, ZLeftOu, nxLeftOu, nyLeftOu, nzLeftOu, XLens, YLens, ZLens,\#            XSensor, YSensor, ZSensor,nxSensor, nySensor, nzSensor,\#                X_LR,Y_LR,Z_LR,Theta1_LR,Theta2_LR,Theta3_LR,\#                    XRightOu, YRightOu, ZRightOu, nxRightOu, nyRightOu, nzRightOu,\#                        mx,my,u0,v0]# m = ms[:,:,0]# res_1 = least_squares(nonlinear_opt,ivs,method='lm',verbose=2,args=(m,M))# print(ivs-res_1.x)# if __name__ == '__main__':#     main()